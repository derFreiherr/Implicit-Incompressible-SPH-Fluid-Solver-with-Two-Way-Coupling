#pragma once
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtx/norm.hpp>
#include <vector>
#include <iostream>
//particleamount___________________________________________________________________________________________________
int var_nx = 36;
int var_ny = 30;
int var_nz = 30;
int var_oneway = 50;
int var_fluidpart = var_nx * var_ny * var_nz;
int var_MaxParticles = var_nx * var_ny * var_nz + (var_oneway * var_oneway * 12);
int var_spezialboundpart = 0;
//constants__________________________________________________________________
float pi_F = glm::pi<float>();
const float h = 0.015625;
const float p0 = 1000;
const float p0p0 = p0 * p0;
const float alpha = 1 / (4 * pi_F * h * h * h); //8 / (pi_F*h*h*h);// 
const float alphaTwoD = 5 / (14 * pi_F * h * h);
const float m = (p0 * h * h * h);
float deltaT = 0.001;
float viscosity = 0.7;
float visc_fluid = 0.7;// 0.0000011;
float visc_boundary = 0.3;// 0.0000011;
float k = 10000;
float cfl_max = 0.4;
float deltaTmax = 0.01;
float cfl = 0;
bool cfl_cond = false;
float avgErr = 0.1;
glm::vec3 gamma = glm::vec3(1, 1, 1);
float gammafloat = 0.7f;
float gammapresup = 0.7f;
float gammadens = 1.f;
float gammapres = 0.7f;
float gammabound = 0.7f;
float omega = 0.5;
float gravity = -9.81f;
//hash___________________________________________________________________________________________
int gridResolution = var_oneway * var_oneway * var_oneway;
float cellsize = 2 * h;
int hashsize = var_MaxParticles;
const int p1 = 73856093;
const int p2 = 19349663;
const int p3 = 83492791;
float searchRadius = 2 * h;
//debug_________________________________________________________________________________________________
std::vector<float> densitys;
std::vector<float> densitysnew;
std::vector<float> currenttimes;
float currentdens;
float neighbouraverage = 0;
float maxvel = 0.f;
float maxdist = 0.f;
//scenarios________________________________________________________________________________________________
bool start = false;
bool tesla = false;
bool teslaclosed = false;
bool realtesla = false;
bool watercol = false;
bool rotatinganimation = false;
bool dambreaktestscen = false;
bool smalldambreaktestscen = false;
bool smallwatercol = false;
bool TwoDwatercol = true;
bool TwoDDambreak = false;

//__________________________________________________________________________________________________
float sizefac = 6;
float distfac = 1;
float overallmaxvel = 0.f;
float cloloroffset = 9.f;
int observing = var_MaxParticles + 1;
float numNeighofobserving;
//importexportstuf_____________________________________________________________________________________________
bool exportdata = false;
bool exportimage = false;
bool exportanimation = false;
bool exportscene = false;
bool importscene = false;
bool exportdens = false;
//__________________________________________________________________________________________________________
glm::vec3 eindrittelvector = glm::vec3(1 / 3, 1 / 3, 1 / 3);
int currentiter = 0;
int currentitermax = 500;
float denistyerrormax = 0.1;
bool newiisph = false;
bool iisph = false;
bool ssph = false;
bool TwoDsimul = true;
int numexport = 0;
float animationtime = 0.f;
float neighSearchTime = 0.f;
float drawingTime = 0.f;
float othercomputationTime = 0.f;
float kerneltime = 0.f;
float densitytime = 0.f;
float nonpresatime = 0.f;
float predveltime = 0.f;
float computeallsftime = 0.f;
float computeallafftime = 0.f;
float looptime = 0.f;
float everythingtime = 0.f;
float overheadtime = 0.f;
bool makesingle = true;
float teslatime = 0.f;
bool maketesla = false;
bool maketeslaclosed = false;
int itertesla = 0;
int boundarya = 10;
int obstaclea = 10;
const int overallmaxpart = 18 * (50 * 50 * 50 + (55 * 55 * 12));
float denserrold = 0.f;
float maxavgdensdeviation = 0.f;
bool singlewall = true;
int avgiter = 0;
int maxiter = 0;
float avgcomptime = 0;
float maxcomptime = 0;
int animationstep = 0;
bool clampp0 = false;
int watercolheight = 50;
float totaltimeanimated = 0;
float simcomptime = 0;
float max_singledens = 0;
int num_rot_part = 140;
float baseRotationSpeed = 0.25;
float angle = 0;
float minypos = 0;
float maxypos = 0;
int animatedparticles = 0;
int animationneighbourscount = 60;
char changename[128];
std::string firstdatapath;
glm::vec3 oldpos;
bool showallpart = true;
bool showboundandouter = false;
bool showouter = false;
float clampfac = 1;
bool absinterrupt = false;
int compbord = 26;
int totalcomp = 0;
bool fixeddt = false;
float maxdenserralltime = 0;
bool paussimul = true;
float oldanimstep = -1;
float totalComputationTime = 0;
float overallmaxcfl = 0;
bool ignoreincomplete = false;
int numunderpop = 0;
float surfacetension = 0;
bool highlightunderpop = false;
bool highlightextremefast = false;
int numofp0high = 0;
bool ignorep0tolow = true;
float upperviualbord = 100;
float lowervisualbord = -10;
bool clamptolow = false;
bool colorvel = true;
bool colordens = false;
bool colorpres = false;
bool setboundmass = true;
bool setpartmass = true;
bool addfloating = false;
float gammapart = 1;
float jitterfac = 0.01;
float maxdenserrold = 0;
bool resetvalues = false;
bool updateviewpos = true;
std::vector<float> maxvels;
std::vector<int> usemefordens;
std::vector<float> cfls;
std::vector<float>iterations;
std::vector < float > densdiffes;
float maxdiffdens = 0;
bool highlightusedforcomp = false;
bool highlightdenserr = false;
float gridbreite = 20;
float gridhöhe = 0;
float densobserving = 0;
float massobserving = 0;
float nonpresaobserving = 0;
float presaobserving = 0;
float sumkernelderobserving = 0;
float sumkernelobserving = 0;
float allrigidmass = 0;
glm::vec3 posofcenterofmass = glm::vec3(0.f, 0.f, 0.f);
glm::vec3 velofcenterofmass = glm::vec3(0.f, 0.f, 0.f);
glm::mat3x3 rotMat = glm::mat3x3(0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f);
glm::vec3 xCM = glm::vec3(0.f, 0.f, 0.f);
glm::vec3 vCM = glm::vec3(0.f, 0.f, 0.f);
glm::mat3 A(0.f);
glm::vec3 L = glm::vec3(0.f, 0.f, 0.f);
glm::mat3 I_inv(0.f);
glm::mat3 inertiaTensor(0.f);
glm::vec3 omegarigidbody = glm::vec3(0.f, 0.f, 0.f);
glm::mat3 inertiaTensorInverse;
glm::vec3 torque(0.f, 0.f, 0.f);
std::vector<std::vector<int>> uniformgidvec1D;

//_________________________________________________________________________________
int windowedWidth = 2048;//small1600;
int windowedHeight = 1152;//small900;
int* wWidth = &windowedWidth;
int* wHeight = &windowedHeight;
glm::vec3 position = glm::vec3(15, 1, 50);